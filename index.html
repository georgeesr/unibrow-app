<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">

    <!-- iOS Home Screen App Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Unibrow Maker">
    <link rel="apple-touch-icon" href="app-icon.png">

    <title>Unibrow Maker</title>

    <!-- Face detection library -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: white;
            overflow-x: hidden;
        }

        .home-screen {
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            overflow: hidden;
            gap: 0;
        }

        .logo {
            padding: 15px 20px;
            margin-bottom: 25px;
            flex-shrink: 0;
        }

        .logo img {
            width: 90px;
            height: auto;
        }

        .title-image {
            padding: 0 20px;
            max-width: 350px;
            width: 80%;
            height: auto;
            margin-bottom: 20px;
            flex-shrink: 0;
        }

        .hero-container {
            width: 100vw;
            position: relative;
            left: 0;
            overflow: hidden;
            margin-bottom: 20px;
            flex-shrink: 1;
        }

        .hero-container img {
            width: 100%;
            height: auto;
            max-height: 60vh;
            object-fit: contain;
            display: block;
        }

        .button-container {
            display: flex;
            flex-direction: row;
            gap: 0;
            padding: 0 20px 20px 20px;
            align-items: center;
            justify-content: flex-start;
            flex-shrink: 0;
        }

        .svg-wrapper:first-child,
        .button-container img:first-child {
            margin-right: auto;
        }

        .svg-wrapper:last-child,
        .button-container img:last-child {
            margin-left: calc(50% - 20px);
        }

        .svg-wrapper,
        .button-container img {
            height: 28.75px;
            cursor: pointer;
            transition: transform 0.2s;
            display: inline-block;
        }

        .svg-wrapper svg {
            height: 28.75px;
            width: auto;
            display: block;
        }

        .svg-wrapper:active,
        .button-container img:active {
            transform: scale(0.95);
        }

        /* Animate red underline in SVG buttons */
        @keyframes growLine {
            from {
                transform: scaleX(0);
            }
            to {
                transform: scaleX(1);
            }
        }

        .animated-line {
            transform-origin: left center;
            animation: growLine 0.8s ease-out forwards;
        }

        .hidden {
            display: none !important;
        }

        /* Editor Screen */
        .editor-screen {
            display: none;
            height: 100vh;
            padding: 10px;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            overflow: hidden;
            position: relative;
        }

        .editor-screen.active {
            display: flex;
        }

        .editor-header {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            flex-shrink: 0;
            background: white;
            z-index: 100;
        }

        .editor-logo {
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .editor-logo:active {
            opacity: 0.7;
        }

        .editor-logo img {
            width: 90px;
            height: auto;
        }

        .editor-title {
            display: flex;
            align-items: center;
        }

        .editor-title img {
            height: 28.75px;
            width: auto;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .editor-title img:active {
            transform: scale(0.95);
        }

        .canvas-container {
            position: relative;
            width: 100vw;
            height: 100vw;
            max-height: 100vh;
            overflow: hidden;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #canvas {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: cover;
        }

        .controls {
            width: 100%;
            max-width: 500px;
            padding: 15px 0;
            flex-shrink: 0;
        }

        .slider-container {
            margin-bottom: 12px;
            padding: 0 20px;
        }

        .slider-label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.95em;
            font-weight: 600;
            color: #333;
        }

        .slider-label-img {
            display: block;
            margin-bottom: 6px;
            height: 10px;
            width: auto;
        }

        .slider {
            width: 100%;
            height: 1px;
            background: #000;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #dc4a38;
            cursor: pointer;
            border: none;
            box-shadow: none;
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #dc4a38;
            cursor: pointer;
            border: none;
            box-shadow: none;
        }


        .action-buttons {
            display: flex;
            gap: 0;
            margin-top: 40px;
            padding: 0 20px;
            justify-content: flex-start;
            align-items: center;
        }

        .action-buttons .svg-wrapper,
        .action-btn-img {
            height: 28.75px;
            cursor: pointer;
            transition: transform 0.2s;
            display: inline-block;
        }

        .action-buttons .svg-wrapper svg {
            height: 28.75px;
            width: auto;
            display: block;
        }

        .action-buttons .svg-wrapper:first-child,
        .action-btn-img:first-child {
            margin-right: auto;
        }

        .action-buttons .svg-wrapper:last-child,
        .action-btn-img:last-child {
            margin-left: auto;
        }

        .action-buttons .svg-wrapper:active,
        .action-btn-img:active {
            transform: scale(0.95);
        }

        /* Camera Modal */
        .camera-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            z-index: 2000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .camera-modal.active {
            display: flex;
        }

        .video-container {
            position: relative;
            width: 100vw;
            aspect-ratio: 1 / 1;
            max-width: 100vh;
            max-height: 100vh;
            overflow: hidden;
            background: black;
        }

        #video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
            object-fit: cover;
        }

        .camera-controls {
            display: flex;
            flex-direction: row;
            gap: 0;
            padding: 0 20px 20px 20px;
            margin-top: 20px;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
        }

        .camera-btn-img {
            height: 28.75px;
            width: auto;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .camera-btn-img:first-child {
            margin-right: auto;
        }

        .camera-btn-img:last-child {
            margin-left: calc(50% - 20px);
        }

        .camera-btn-img:active {
            transform: scale(0.95);
        }

        .modal-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
        }

        .modal-btn-img {
            height: 28.75px;
            width: auto;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .modal-btn-img:last-child {
            margin-top: 20px;
        }

        .modal-btn-img:active {
            transform: scale(0.95);
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1em;
            margin-top: 10px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: transparent;
            padding: 20px;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 6px solid rgba(220, 74, 56, 0.3);
            border-top: 6px solid #dc4a38;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        #loadingMessage {
            display: none;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Home Screen -->
    <div class="home-screen" id="homeScreen">
        <div class="logo">
            <img src="mfah_logo.png" alt="MFAH Logo">
        </div>
        <img src="fk_unibrow_title.svg" alt="Frida Kahlo Unibrow Generator" class="title-image">
        <div class="hero-container">
            <img src="frida-eyes.jpg" alt="Frida Kahlo Eyes">
        </div>
        <div class="button-container">
            <div id="takePicBtn" class="svg-wrapper">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 344.29 92.9" preserveAspectRatio="xMinYMin meet">
                    <g>
                        <path d="M24.12,54.39h-10.56V10.2H0V.97h37.68v9.23h-13.56v44.19Z"/>
                        <path d="M56.5.97h12.92l14.42,53.42h-10.56l-3.29-13.2h-14.13l-3.22,13.2h-10.56L56.5.97ZM62.94,10.63l-4.97,21.86h9.98l-5.01-21.86Z"/>
                        <path d="M89.2.97h10.56v21.11L116.29.97h11.95l-16.85,21.04,17.46,32.38h-11.74l-12.67-24.05-4.69,5.94v18.11h-10.56V.97Z"/>
                        <path d="M168.42,54.39h-33.28V.97h33.28v9.3h-22.72v11.52h20.57v9.3h-20.57v13.99h22.72v9.3Z"/>
                        <path d="M223.17.97h14.49c7.37,0,12.67,1.31,15.91,3.94,3.23,2.62,4.85,6.88,4.85,12.77s-1.62,10.15-4.85,12.77c-3.23,2.62-8.53,3.94-15.91,3.94h-3.94v20h-10.56V.97ZM233.73,9.84v15.67h4.33c3.46,0,5.89-.58,7.28-1.75,1.39-1.17,2.09-3.2,2.09-6.08s-.7-4.91-2.09-6.08c-1.4-1.17-3.82-1.75-7.28-1.75h-4.33Z"/>
                        <path d="M267.65,10.27V.97h31.81v9.3h-10.63v34.82h10.63v9.3h-31.81v-9.3h10.63V10.27h-10.63Z"/>
                        <path d="M344.29,52.85c-1.67.86-3.42,1.5-5.26,1.93-1.84.43-3.77.64-5.8.64-7.2,0-12.7-2.37-16.5-7.12-3.79-4.75-5.69-11.6-5.69-20.57s1.9-15.86,5.69-20.61c3.79-4.75,9.29-7.12,16.5-7.12,2.03,0,3.97.21,5.83.64s3.6,1.07,5.22,1.93v11.74c-1.81-1.67-3.57-2.89-5.28-3.67-1.71-.77-3.47-1.16-5.28-1.16-3.86,0-6.78,1.53-8.75,4.6-1.97,3.07-2.95,7.62-2.95,13.65s.98,10.55,2.95,13.61c1.97,3.07,4.88,4.6,8.75,4.6,1.81,0,3.57-.39,5.28-1.16,1.71-.77,3.46-2,5.28-3.67v11.74Z"/>
                    </g>
                    <rect class="animated-line" fill="#dc4a38" y="73.08" width="317.16" height="19.82"/>
                </svg>
            </div>
            <div id="uploadPicBtn" class="svg-wrapper">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 431.96 92.9" preserveAspectRatio="xMinYMin meet">
                    <rect class="animated-line" fill="#dc4a38" y="73.08" width="317.16" height="19.82"/>
                    <g>
                        <path d="M0,34.67V.97h10.56v36.35c0,2.67.68,4.77,2.04,6.28,1.36,1.51,3.24,2.27,5.65,2.27s4.29-.76,5.65-2.27c1.36-1.51,2.04-3.61,2.04-6.28V.97h10.56v33.71c0,7.25-1.44,12.52-4.33,15.82-2.89,3.29-7.53,4.94-13.92,4.94s-11-1.65-13.9-4.94c-2.9-3.29-4.35-8.56-4.35-15.82Z"/>
                        <path d="M46.12.97h14.49c7.37,0,12.67,1.31,15.91,3.94,3.23,2.62,4.85,6.88,4.85,12.77s-1.62,10.15-4.85,12.77c-3.23,2.62-8.53,3.94-15.91,3.94h-3.94v20h-10.56V.97ZM56.68,9.84v15.67h4.33c3.46,0,5.89-.58,7.28-1.75s2.09-3.2,2.09-6.08-.7-4.91-2.09-6.08c-1.4-1.17-3.82-1.75-7.28-1.75h-4.33Z"/>
                        <path d="M92.5,54.39V.97h10.56v44.12h22.58v9.3h-33.13Z"/>
                        <path d="M131.86,27.73c0-9.14,1.58-16.04,4.74-20.72,3.16-4.67,7.83-7.01,14.01-7.01s10.88,2.34,14.04,7.01c3.16,4.68,4.74,11.58,4.74,20.72s-1.58,16.01-4.74,20.68c-3.16,4.68-7.84,7.01-14.04,7.01s-10.85-2.34-14.01-7.01c-3.16-4.67-4.74-11.57-4.74-20.68ZM150.6,9.48c-2.7,0-4.66,1.44-5.9,4.31-1.24,2.88-1.86,7.52-1.86,13.94s.62,11.03,1.86,13.9c1.24,2.88,3.21,4.31,5.9,4.31s4.7-1.44,5.94-4.31c1.24-2.88,1.86-7.51,1.86-13.9s-.62-11.06-1.86-13.94c-1.24-2.87-3.22-4.31-5.94-4.31Z"/>
                        <path d="M188.28.97h12.92l14.42,53.42h-10.56l-3.29-13.2h-14.13l-3.22,13.2h-10.56L188.28.97ZM194.72,10.63l-4.97,21.86h9.98l-5.01-21.86Z"/>
                        <path d="M221.7.97h11.31c8.73,0,15.02,2.08,18.86,6.24,3.84,4.16,5.76,10.97,5.76,20.41s-1.92,16.3-5.76,20.49c-3.84,4.19-10.13,6.28-18.86,6.28h-11.31V.97ZM232.26,10.48v34.39h2.86c4.15,0,7.11-1.31,8.87-3.92,1.76-2.61,2.65-7.06,2.65-13.33s-.88-10.64-2.65-13.24c-1.77-2.6-4.72-3.9-8.87-3.9h-2.86Z"/>
                        <path d="M310.83.97h14.49c7.37,0,12.67,1.31,15.91,3.94,3.23,2.62,4.85,6.88,4.85,12.77s-1.62,10.15-4.85,12.77c-3.23,2.62-8.53,3.94-15.91,3.94h-3.94v20h-10.56V.97ZM321.39,9.84v15.67h4.33c3.46,0,5.89-.58,7.28-1.75,1.39-1.17,2.09-3.2,2.09-6.08s-.7-4.91-2.09-6.08c-1.4-1.17-3.82-1.75-7.28-1.75h-4.33Z"/>
                        <path d="M355.31,10.27V.97h31.81v9.3h-10.63v34.81h10.63v9.3h-31.81v-9.3h10.63V10.27h-10.63Z"/>
                        <path d="M431.96,52.85c-1.67.86-3.42,1.5-5.26,1.93s-3.77.64-5.8.64c-7.2,0-12.7-2.37-16.5-7.12-3.79-4.75-5.69-11.6-5.69-20.57s1.9-15.86,5.69-20.61c3.79-4.75,9.29-7.12,16.5-7.12,2.03,0,3.97.21,5.83.64s3.6,1.07,5.22,1.93v11.74c-1.81-1.67-3.57-2.89-5.28-3.67-1.71-.77-3.47-1.16-5.28-1.16-3.86,0-6.78,1.53-8.75,4.6-1.97,3.07-2.95,7.62-2.95,13.65s.98,10.55,2.95,13.62,4.88,4.6,8.75,4.6c1.81,0,3.57-.39,5.28-1.16,1.71-.77,3.46-2,5.28-3.67v11.74Z"/>
                    </g>
                </svg>
            </div>
        </div>
    </div>

    <!-- Editor Screen -->
    <div class="editor-screen" id="editorScreen">
        <div class="editor-header">
            <div class="editor-logo" id="homeLogoBtn">
                <img src="mfah_logo.png" alt="MFAH Logo">
            </div>
            <div class="editor-title">
                <img src="share_app.svg" alt="Share App" id="shareAppBtn">
            </div>
        </div>
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div class="controls">
            <div class="slider-container">
                <img src="intensity.svg" alt="Unibrow Intensity" class="slider-label-img">
                <input type="range" min="0" max="100" value="0" class="slider" id="unibrowSlider">
            </div>
            <div class="slider-container">
                <img src="darkness.svg" alt="Darkness" class="slider-label-img">
                <input type="range" min="-50" max="50" value="0" class="slider" id="darknessSlider">
            </div>
            <div class="slider-container">
                <img src="highlights.svg" alt="Highlights" class="slider-label-img">
                <input type="range" min="0" max="100" value="0" class="slider" id="colorSlider">
            </div>
            <div class="action-buttons">
                <div id="newPicBtn" class="svg-wrapper">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 440.94 92.99" preserveAspectRatio="xMinYMin meet">
                        <rect class="animated-line" fill="#dc4a38" y="73.17" width="317.16" height="19.82"/>
                        <g>
                            <path d="M.56,34.91V.97h10.63v36.6c0,2.69.68,4.8,2.05,6.32,1.37,1.53,3.27,2.29,5.69,2.29s4.32-.76,5.69-2.29c1.37-1.52,2.05-3.63,2.05-6.32V.97h10.63v33.94c0,7.3-1.45,12.61-4.36,15.92-2.91,3.31-7.58,4.97-14.01,4.97s-11.08-1.66-14-4.97S.56,42.21.56,34.91Z"/>
                            <path d="M47,.97h14.59c7.42,0,12.76,1.32,16.01,3.96s4.88,6.93,4.88,12.86-1.63,10.22-4.88,12.86c-3.25,2.64-8.59,3.96-16.01,3.96h-3.96v20.14h-10.63V.97ZM57.63,9.91v15.78h4.36c3.48,0,5.93-.59,7.33-1.77,1.4-1.18,2.11-3.22,2.11-6.12s-.7-4.95-2.11-6.12c-1.41-1.18-3.85-1.77-7.33-1.77h-4.36Z"/>
                            <path d="M93.69,54.76V.97h10.63v44.42h22.73v9.37h-33.36Z"/>
                            <path d="M133.32,27.92c0-9.2,1.59-16.15,4.77-20.86,3.18-4.71,7.88-7.06,14.1-7.06s10.96,2.35,14.14,7.06c3.18,4.71,4.77,11.66,4.77,20.86s-1.59,16.12-4.77,20.82c-3.18,4.71-7.9,7.06-14.14,7.06s-10.92-2.35-14.1-7.06c-3.18-4.71-4.77-11.65-4.77-20.82ZM152.19,9.55c-2.71,0-4.7,1.45-5.94,4.34-1.25,2.89-1.87,7.57-1.87,14.03s.62,11.1,1.87,14c1.25,2.89,3.23,4.34,5.94,4.34s4.73-1.45,5.98-4.34c1.25-2.89,1.87-7.56,1.87-14s-.62-11.14-1.87-14.03c-1.25-2.89-3.24-4.34-5.98-4.34Z"/>
                            <path d="M190.13.97h13l14.52,53.79h-10.63l-3.31-13.29h-14.23l-3.24,13.29h-10.63L190.13.97ZM196.61,10.7l-5.01,22.01h10.05l-5.04-22.01Z"/>
                            <path d="M223.78.97h11.38c8.79,0,15.12,2.1,18.99,6.29,3.87,4.19,5.8,11.04,5.8,20.55s-1.93,16.41-5.8,20.62c-3.87,4.21-10.2,6.32-18.99,6.32h-11.38V.97ZM234.4,10.56v34.62h2.88c4.18,0,7.16-1.31,8.93-3.94,1.78-2.63,2.67-7.1,2.67-13.42s-.89-10.71-2.67-13.33c-1.78-2.62-4.76-3.93-8.93-3.93h-2.88Z"/>
                            <path d="M311.97.97h11.42l14.99,39.09V.97h9.37v53.79h-11.35l-15.06-39.09v39.09h-9.37V.97Z"/>
                            <path d="M391.65,54.76h-33.5V.97h33.5v9.37h-22.88v11.6h20.71v9.37h-20.71v14.09h22.88v9.37Z"/>
                            <path d="M396.52.97h9.29l3.85,39.48,4.65-25.54h8.83l5.4,25.54,3.03-39.48h9.37l-6.2,53.79h-9.91l-6.12-28.24-5.73,28.24h-9.83l-6.63-53.79Z"/>
                        </g>
                    </svg>
                </div>
                <img src="share.svg" alt="Share" id="shareBtn" class="action-btn-img">
            </div>
        </div>
        <div class="loading" id="loadingText" style="display: none;">
            <div class="spinner"></div>
            <div id="loadingMessage">Detecting face...</div>
        </div>
    </div>

    <!-- Camera Modal -->
    <div class="camera-modal" id="cameraModal">
        <div class="video-container">
            <video id="video" autoplay playsinline></video>
        </div>
        <div class="camera-controls">
            <img src="capture.svg" alt="Capture" id="captureBtn" class="camera-btn-img">
            <img src="close.svg" alt="Close" id="closeCameraBtn" class="camera-btn-img">
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept="image/*" style="display: none;">

    <!-- Upload New Pic Modal -->
    <div class="camera-modal" id="newPicModal">
        <div class="modal-buttons">
            <img src="take_pic.svg" alt="Take a Pic" id="modalTakePicBtn" class="modal-btn-img">
            <img src="upload_pic.svg" alt="Upload a Pic" id="modalUploadPicBtn" class="modal-btn-img">
            <img src="close.svg" alt="Cancel" id="closeNewPicModal" class="modal-btn-img">
        </div>
    </div>

    <script>
        // Elements
        const homeScreen = document.getElementById('homeScreen');
        const editorScreen = document.getElementById('editorScreen');
        const takePicBtn = document.getElementById('takePicBtn');
        const uploadPicBtn = document.getElementById('uploadPicBtn');
        const fileInput = document.getElementById('fileInput');
        const cameraModal = document.getElementById('cameraModal');
        const video = document.getElementById('video');
        const captureBtn = document.getElementById('captureBtn');
        const closeCameraBtn = document.getElementById('closeCameraBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const unibrowSlider = document.getElementById('unibrowSlider');
        const darknessSlider = document.getElementById('darknessSlider');
        const colorSlider = document.getElementById('colorSlider');
        const newPicBtn = document.getElementById('newPicBtn');
        const shareBtn = document.getElementById('shareBtn');
        const loadingText = document.getElementById('loadingText');
        const loadingMessage = document.getElementById('loadingMessage');
        const newPicModal = document.getElementById('newPicModal');
        const modalTakePicBtn = document.getElementById('modalTakePicBtn');
        const modalUploadPicBtn = document.getElementById('modalUploadPicBtn');
        const closeNewPicModal = document.getElementById('closeNewPicModal');
        const homeLogoBtn = document.getElementById('homeLogoBtn');
        const shareAppBtn = document.getElementById('shareAppBtn');

        let originalImage = null;
        let faceLandmarks = null;
        let stream = null;
        let faceMesh = null;
        let stampImage = null;

        // Load stamp image
        stampImage = new Image();
        stampImage.src = 'stamp.svg';

        // Initialize MediaPipe Face Mesh
        function initFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`;
                }
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onFaceMeshResults);
        }

        // Handle face mesh results
        function onFaceMeshResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                faceLandmarks = results.multiFaceLandmarks[0];
                loadingText.style.display = 'none';
                drawCanvas();
            } else {
                faceLandmarks = null;
                loadingMessage.textContent = 'No face detected. Please try another image.';
            }
        }

        // Resize image for faster processing
        function resizeImageForProcessing(image) {
            const maxDimension = 1280;
            let width = image.width;
            let height = image.height;

            if (width <= maxDimension && height <= maxDimension) {
                return image;
            }

            const tempCanvas = document.createElement('canvas');
            if (width > height) {
                tempCanvas.width = maxDimension;
                tempCanvas.height = (height / width) * maxDimension;
            } else {
                tempCanvas.height = maxDimension;
                tempCanvas.width = (width / height) * maxDimension;
            }

            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(image, 0, 0, tempCanvas.width, tempCanvas.height);

            const resizedImage = new Image();
            resizedImage.src = tempCanvas.toDataURL('image/jpeg', 0.9);
            return resizedImage;
        }

        // Process image for face detection
        async function detectFace(image) {
            loadingText.style.display = 'block';
            loadingMessage.textContent = 'Detecting face...';

            if (!faceMesh) {
                loadingMessage.textContent = 'Loading face detection...';
                initFaceMesh();
                // Wait a bit for initialization
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            loadingMessage.textContent = 'Analyzing image...';
            const processImage = resizeImageForProcessing(image);

            if (processImage !== image) {
                await new Promise(resolve => {
                    processImage.onload = resolve;
                });
            }

            await faceMesh.send({image: processImage});
        }

        // Draw canvas with unibrow
        function drawCanvas() {
            if (!originalImage) return;

            // Set canvas to square based on smaller dimension to ensure full coverage
            const size = Math.min(originalImage.width, originalImage.height);
            canvas.width = size;
            canvas.height = size;

            console.log('Original image:', originalImage.width, 'x', originalImage.height);
            console.log('Canvas size:', canvas.width, 'x', canvas.height);

            // Calculate crop to center the image in square
            const sourceSize = size;
            const sourceX = (originalImage.width - size) / 2;
            const sourceY = (originalImage.height - size) / 2;

            // Draw original image cropped to square
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(
                originalImage,
                sourceX, sourceY, sourceSize, sourceSize,  // source crop
                0, 0, size, size  // destination
            );

            // Draw unibrow if landmarks exist
            if (faceLandmarks && unibrowSlider.value > 0) {
                drawUnibrow();
            }

            // Draw stamp in bottom right corner
            if (stampImage && stampImage.complete) {
                // Position stamp in bottom right corner - maintain aspect ratio
                const stampWidth = canvas.width * 0.25; // 25% of image width
                const stampHeight = (stampImage.height / stampImage.width) * stampWidth; // Maintain aspect ratio
                const bottomMargin = canvas.width * 0.03; // 3% margin on bottom only
                const stampX = canvas.width - stampWidth; // Flush against right edge (no margin)
                const stampY = canvas.height - stampHeight - bottomMargin; // Bottom edge with margin

                // Draw stamp without rotation
                ctx.drawImage(stampImage, stampX, stampY, stampWidth, stampHeight);
            }
        }

        // Draw unibrow based on eyebrow landmarks
        function drawUnibrow() {
            const intensity = unibrowSlider.value / 100;
            if (intensity === 0) return;

            // Calculate crop offset for landmark adjustment
            const size = Math.min(originalImage.width, originalImage.height);
            const offsetX = (originalImage.width - size) / 2;
            const offsetY = (originalImage.height - size) / 2;

            // Get all eyebrow landmark points for accurate shape
            // Left eyebrow landmarks (outer to inner): 46, 53, 52, 65, 55
            const leftBrowPoints = [46, 53, 52, 65, 55].map(idx => ({
                x: (faceLandmarks[idx].x * originalImage.width - offsetX) * (canvas.width / size),
                y: (faceLandmarks[idx].y * originalImage.height - offsetY) * (canvas.height / size)
            }));

            // Right eyebrow landmarks (inner to outer): 285, 295, 282, 283, 276
            const rightBrowPoints = [285, 295, 282, 283, 276].map(idx => ({
                x: (faceLandmarks[idx].x * originalImage.width - offsetX) * (canvas.width / size),
                y: (faceLandmarks[idx].y * originalImage.height - offsetY) * (canvas.height / size)
            }));

            // Combine into one continuous path (left to right)
            const allBrowPoints = [...leftBrowPoints, ...rightBrowPoints];

            // Add bridge points to connect the eyebrows smoothly
            const bridge = faceLandmarks[168]; // Nose bridge
            const bridgePoint = {
                x: (bridge.x * originalImage.width - offsetX) * (canvas.width / size),
                y: (bridge.y * originalImage.height - offsetY) * (canvas.height / size) - 5
            };

            // Insert bridge point between the two eyebrows
            const fullUnibrowPath = [
                ...leftBrowPoints,
                bridgePoint,
                ...rightBrowPoints
            ];

            ctx.save();
            ctx.globalAlpha = 0.9;

            // Enable anti-aliasing for smoother hair
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Sample eyebrow color from the original image
            function sampleEyebrowColor() {
                // Sample multiple points from both eyebrows
                const samplePoints = [
                    faceLandmarks[46], faceLandmarks[53], faceLandmarks[55], // Left eyebrow
                    faceLandmarks[276], faceLandmarks[283], faceLandmarks[285] // Right eyebrow
                ];

                let totalR = 0, totalG = 0, totalB = 0;
                let samples = 0;

                samplePoints.forEach(point => {
                    const x = Math.floor(point.x * canvas.width);
                    const y = Math.floor(point.y * canvas.height);

                    // Sample a small area around each point
                    for (let dx = -2; dx <= 2; dx++) {
                        for (let dy = -2; dy <= 2; dy++) {
                            const px = x + dx;
                            const py = y + dy;
                            if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                                const pixel = ctx.getImageData(px, py, 1, 1).data;
                                totalR += pixel[0];
                                totalG += pixel[1];
                                totalB += pixel[2];
                                samples++;
                            }
                        }
                    }
                });

                // Average color
                let avgR = Math.floor(totalR / samples);
                let avgG = Math.floor(totalG / samples);
                let avgB = Math.floor(totalB / samples);

                // Apply darkness adjustment (-50 to +50)
                // At max darkness (+50), force eyebrows to be very dark/black
                const darknessValue = parseInt(darknessSlider.value);

                if (darknessValue > 0) {
                    // Darken mode: multiply by percentage to force toward black
                    const darknessFactor = 1 - (darknessValue / 50 * 0.9); // Up to 90% darker
                    avgR = Math.floor(avgR * darknessFactor);
                    avgG = Math.floor(avgG * darknessFactor);
                    avgB = Math.floor(avgB * darknessFactor);
                } else {
                    // Lighten mode: simple subtraction
                    avgR = Math.min(255, avgR - darknessValue);
                    avgG = Math.min(255, avgG - darknessValue);
                    avgB = Math.min(255, avgB - darknessValue);
                }

                // Apply highlights (0-100)
                const highlightValue = parseInt(colorSlider.value) / 100;

                // Create color variations with highlights
                // Base color stays the same, but we add lighter variations for highlights
                const colors = [
                    `rgba(${avgR}, ${avgG}, ${avgB}, 0.9)`,
                    `rgba(${Math.max(0, avgR - 15)}, ${Math.max(0, avgG - 15)}, ${Math.max(0, avgB - 15)}, 0.9)`,
                    `rgba(${Math.max(0, avgR - 30)}, ${Math.max(0, avgG - 30)}, ${Math.max(0, avgB - 30)}, 0.95)`,
                    `rgba(${Math.min(255, avgR + 10)}, ${Math.min(255, avgG + 10)}, ${Math.min(255, avgB + 10)}, 0.85)`
                ];

                // Add highlighted strands (lighter versions)
                if (highlightValue > 0) {
                    const highlightBoost = highlightValue * 80; // 0 to 80 RGB boost
                    colors.push(
                        `rgba(${Math.min(255, avgR + highlightBoost)}, ${Math.min(255, avgG + highlightBoost)}, ${Math.min(255, avgB + highlightBoost)}, 0.85)`,
                        `rgba(${Math.min(255, avgR + highlightBoost * 0.7)}, ${Math.min(255, avgG + highlightBoost * 0.7)}, ${Math.min(255, avgB + highlightBoost * 0.7)}, 0.8)`,
                        `rgba(${Math.min(255, avgR + highlightBoost * 1.2)}, ${Math.min(255, avgG + highlightBoost * 1.2)}, ${Math.min(255, avgB + highlightBoost * 1.2)}, 0.75)`
                    );
                }

                return colors;
            }

            const eyebrowColors = sampleEyebrowColor();

            // Function to interpolate along the eyebrow curve
            function getPointOnCurve(t) {
                // t is 0 to 1 along the entire curve
                const totalSegments = fullUnibrowPath.length - 1;
                const segment = Math.min(Math.floor(t * totalSegments), totalSegments - 1);
                const localT = (t * totalSegments) - segment;

                const p1 = fullUnibrowPath[segment];
                const p2 = fullUnibrowPath[segment + 1];

                return {
                    x: p1.x + (p2.x - p1.x) * localT,
                    y: p1.y + (p2.y - p1.y) * localT
                };
            }

            // Function to get the angle/direction at a point on the curve
            function getAngleAtPoint(t) {
                const totalSegments = fullUnibrowPath.length - 1;
                const segment = Math.min(Math.floor(t * totalSegments), totalSegments - 1);

                const p1 = fullUnibrowPath[segment];
                const p2 = fullUnibrowPath[segment + 1];

                // Tangent angle of the curve at this point
                const tangentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

                // Perpendicular to the curve (upward/outward from eyebrow)
                return tangentAngle - Math.PI / 2;
            }

            // Helper function for gaussian distribution (more natural clustering)
            function gaussianRandom() {
                let u = 0, v = 0;
                while(u === 0) u = Math.random();
                while(v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            }

            // Add randomized noise seed for variation
            const noiseSeed = Math.random() * 1000;

            // Draw base hair layer following the exact eyebrow shape - MUCH BUSHIER!
            const numStrokes = Math.floor(400 + intensity * 3000);

            for (let i = 0; i < numStrokes; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                // Much wider spread for bushiness and thickness with gaussian distribution
                const spreadRadius = 40 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                // Mix gaussian and uniform for varied clustering
                const distMix = Math.random();
                const randomDist = distMix < 0.7
                    ? Math.abs(gaussianRandom()) * spreadRadius * 0.4
                    : Math.random() * spreadRadius * 0.6;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                // Hair grows perpendicular to eyebrow curve with more variation
                // Add smooth flowing variation with randomized patterns
                const flowVariation = Math.sin(t * Math.PI * 4 + noiseSeed + i * 0.01) * 0.3;
                const turbulence = Math.sin(t * Math.PI * 7 + noiseSeed * 2) * 0.2;
                const angleVariation = (Math.random() - 0.5) * 1.0 + flowVariation + turbulence;
                const hairAngle = baseAngle + angleVariation;

                // Longer, wilder hair
                const hairLength = (15 + Math.random() * 35) * (0.6 + intensity * 1.4);
                const thickness = 1.2 + Math.random() * 2.5;

                // Use sampled eyebrow colors with varied opacity for depth
                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.4 + Math.random() * 0.4; // Softer, more varied opacity
                ctx.strokeStyle = baseColor.replace(/[\d\.]+\)$/g, opacity + ')');
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw curved hair with more wildness and gradient effect
                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;
                const controlX = startX + Math.cos(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 5;
                const controlY = startY + Math.sin(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 5;

                // Create gradient for tapered, soft hair effect
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.8) + ')'));
                gradient.addColorStop(0.6, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.3) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, '0)'));
                ctx.strokeStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                ctx.stroke();
            }

            // Add MORE density layers for extreme bushiness
            const densityStrokes = Math.floor(300 + intensity * 1600);
            for (let i = 0; i < densityStrokes; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                const spreadRadius = 38 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const distMix = Math.random();
                const randomDist = distMix < 0.65
                    ? Math.abs(gaussianRandom()) * spreadRadius * 0.4
                    : Math.random() * spreadRadius * 0.55;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                const flowVariation = Math.sin(t * Math.PI * 3 + noiseSeed * 0.8 + i * 0.015) * 0.25;
                const turbulence = Math.sin(t * Math.PI * 6 + noiseSeed * 1.5) * 0.15;
                const angleVariation = (Math.random() - 0.5) * 0.9 + flowVariation + turbulence;
                const hairAngle = baseAngle + angleVariation;

                const hairLength = (18 + Math.random() * 40) * (0.7 + intensity * 1.2);
                const thickness = 1.5 + Math.random() * 2.8;

                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.4 + Math.random() * 0.3;

                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;

                // Tapered gradient with soft edges
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.7) + ')'));
                gradient.addColorStop(0.5, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.4) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, '0)'));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }

            // Add EXTRA thick and wild foreground hairs
            const thickHairs = Math.floor(160 + intensity * 800);
            for (let i = 0; i < thickHairs; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                const spreadRadius = 45 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const distMix = Math.random();
                const randomDist = distMix < 0.6
                    ? Math.abs(gaussianRandom()) * spreadRadius * 0.45
                    : Math.random() * spreadRadius * 0.65;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                const flowVariation = Math.sin(t * Math.PI * 2.5 + noiseSeed * 1.2 + i * 0.02) * 0.35;
                const turbulence = Math.sin(t * Math.PI * 5 + noiseSeed * 2.5) * 0.25;
                const angleVariation = (Math.random() - 0.5) * 1.1 + flowVariation + turbulence;
                const hairAngle = baseAngle + angleVariation;

                const hairLength = (22 + Math.random() * 45) * (0.8 + intensity * 1.1);
                const thickness = 2.2 + Math.random() * 3.5;

                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.5 + Math.random() * 0.3;

                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;
                const controlX = startX + Math.cos(hairAngle) * hairLength * 0.6 + (Math.random() - 0.5) * 6;
                const controlY = startY + Math.sin(hairAngle) * hairLength * 0.6 + (Math.random() - 0.5) * 6;

                // Tapered thick hair with very soft edges
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.8) + ')'));
                gradient.addColorStop(0.5, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.5) + ')'));
                gradient.addColorStop(0.85, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.15) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, '0)'));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                ctx.stroke();
            }

            // Add super wild stray hairs for maximum bushiness
            const strayHairs = Math.floor(100 + intensity * 600);
            for (let i = 0; i < strayHairs; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                const spreadRadius = 50 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const distMix = Math.random();
                const randomDist = distMix < 0.55
                    ? Math.abs(gaussianRandom()) * spreadRadius * 0.5
                    : Math.random() * spreadRadius * 0.7;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                // More extreme angle variation for wild strays with flow
                const flowVariation = Math.sin(t * Math.PI * 2 + noiseSeed * 1.8 + i * 0.025) * 0.4;
                const turbulence = Math.sin(t * Math.PI * 4.5 + noiseSeed * 3) * 0.3;
                const angleVariation = (Math.random() - 0.5) * 1.4 + flowVariation + turbulence;
                const hairAngle = baseAngle + angleVariation;

                const hairLength = (18 + Math.random() * 35) * (0.9 + intensity * 0.8);
                const thickness = 1.3 + Math.random() * 2.2;

                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.3 + Math.random() * 0.3;

                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;
                const controlX = startX + Math.cos(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 8;
                const controlY = startY + Math.sin(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 8;

                // Very subtle tapered stray hair with soft wispy edges
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.7) + ')'));
                gradient.addColorStop(0.6, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.3) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, '0)'));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Take picture button
        takePicBtn.addEventListener('click', openCamera);

        // Capture button
        captureBtn.addEventListener('click', () => {
            const tempCanvas = document.createElement('canvas');

            // Crop to square based on smaller dimension
            const sourceSize = Math.min(video.videoWidth, video.videoHeight);

            // Scale down to max 2000x2000 for faster loading
            const maxSize = 2000;
            const targetSize = Math.min(sourceSize, maxSize);

            tempCanvas.width = targetSize;
            tempCanvas.height = targetSize;
            const tempCtx = tempCanvas.getContext('2d');

            // Calculate crop offset to center the video
            const sourceX = (video.videoWidth - sourceSize) / 2;
            const sourceY = (video.videoHeight - sourceSize) / 2;

            // Flip and draw cropped square
            tempCtx.translate(targetSize, 0);
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(video, sourceX, sourceY, sourceSize, sourceSize, 0, 0, targetSize, targetSize);

            originalImage = new Image();
            originalImage.onload = () => {
                homeScreen.classList.add('hidden');
                editorScreen.classList.add('active');
                detectFace(originalImage);
                closeCamera();
            };
            originalImage.src = tempCanvas.toDataURL('image/jpeg', 0.90);
        });

        // Close camera
        closeCameraBtn.addEventListener('click', closeCamera);

        async function openCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                cameraModal.classList.add('active');
            } catch (error) {
                alert('Camera access denied or unavailable.');
            }
        }

        function closeCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            cameraModal.classList.remove('active');
        }

        // Upload picture button
        uploadPicBtn.addEventListener('click', () => {
            fileInput.click();
        });

        // File input change
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Show loading immediately
                homeScreen.classList.add('hidden');
                editorScreen.classList.add('active');
                loadingText.style.display = 'block';
                loadingMessage.textContent = 'Loading image...';

                const reader = new FileReader();
                reader.onload = (event) => {
                    const tempImage = new Image();
                    tempImage.onload = () => {
                        // Resize uploaded image to max 2000x2000 for performance
                        const maxSize = 2000;
                        const sourceSize = Math.min(tempImage.width, tempImage.height);
                        const targetSize = Math.min(sourceSize, maxSize);

                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = targetSize;
                        tempCanvas.height = targetSize;
                        const tempCtx = tempCanvas.getContext('2d');

                        // Center crop to square
                        const sourceX = (tempImage.width - sourceSize) / 2;
                        const sourceY = (tempImage.height - sourceSize) / 2;
                        tempCtx.drawImage(tempImage, sourceX, sourceY, sourceSize, sourceSize, 0, 0, targetSize, targetSize);

                        // Create optimized image
                        originalImage = new Image();
                        originalImage.onload = () => {
                            detectFace(originalImage);
                        };
                        originalImage.src = tempCanvas.toDataURL('image/jpeg', 0.90);
                    };
                    tempImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Slider inputs
        unibrowSlider.addEventListener('input', () => {
            drawCanvas();
        });

        darknessSlider.addEventListener('input', () => {
            drawCanvas();
        });

        colorSlider.addEventListener('input', () => {
            drawCanvas();
        });

        // Home logo button - go back to home screen
        homeLogoBtn.addEventListener('click', () => {
            editorScreen.classList.remove('active');
            homeScreen.classList.remove('hidden');
            // Reset sliders
            unibrowSlider.value = 0;
            darknessSlider.value = 0;
            colorSlider.value = 0;
        });

        // Upload New Pic button - show modal
        newPicBtn.addEventListener('click', () => {
            newPicModal.classList.add('active');
        });

        // Close new pic modal
        closeNewPicModal.addEventListener('click', () => {
            newPicModal.classList.remove('active');
        });

        // Modal Take Pic button
        modalTakePicBtn.addEventListener('click', () => {
            newPicModal.classList.remove('active');
            openCamera();
        });

        // Modal Upload Pic button
        modalUploadPicBtn.addEventListener('click', () => {
            newPicModal.classList.remove('active');
            fileInput.click();
        });

        // Share button
        shareBtn.addEventListener('click', async () => {
            try {
                // Create a new square canvas to ensure 1:1 ratio
                const exportCanvas = document.createElement('canvas');
                const size = Math.min(canvas.width, canvas.height);
                exportCanvas.width = size;
                exportCanvas.height = size;
                const exportCtx = exportCanvas.getContext('2d');

                // Draw the main canvas onto the export canvas (should already be square)
                exportCtx.drawImage(canvas, 0, 0, size, size);

                console.log('Export canvas size:', exportCanvas.width, 'x', exportCanvas.height);

                exportCanvas.toBlob(async (blob) => {
                    const file = new File([blob], 'my-unibrow.jpg', { type: 'image/jpeg' });

                    if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share({
                                files: [file],
                                title: 'My Unibrow Creation',
                                text: 'Check out my unibrow!'
                            });
                        } catch (err) {
                            if (err.name !== 'AbortError') {
                                alert('Could not share.');
                            }
                        }
                    } else {
                        alert('Sharing not supported on this device.');
                    }
                }, 'image/jpeg', 0.92);
            } catch (err) {
                alert('Could not share.');
            }
        });

        // Share App button
        shareAppBtn.addEventListener('click', async () => {
            try {
                const appUrl = window.location.href;
                if (navigator.share) {
                    await navigator.share({
                        title: 'Frida Kahlo Unibrow Generator',
                        text: 'Create your own Frida Kahlo-inspired unibrow! Try this fun app:',
                        url: appUrl
                    });
                } else {
                    // Fallback for browsers that don't support Web Share API
                    await navigator.clipboard.writeText(appUrl);
                    alert('App link copied to clipboard!');
                }
            } catch (err) {
                if (err.name !== 'AbortError') {
                    console.error('Share failed:', err);
                }
            }
        });
    </script>
</body>
</html>
