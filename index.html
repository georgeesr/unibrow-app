<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">

    <!-- iOS Home Screen App Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Unibrow Maker">
    <link rel="apple-touch-icon" href="app-icon.png">

    <title>Unibrow Maker</title>

    <!-- Face detection library -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: url('new_images/unibrow_background_rf.jpg') center center / cover no-repeat;
            background-attachment: fixed;
            overflow-x: hidden;
        }

        .home-screen {
            text-align: center;
            padding: 40px 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .title-image {
            max-width: 400px;
            width: 90%;
            height: auto;
            margin-bottom: 40px;
        }

        .button-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 100%;
            max-width: 300px;
        }

        .main-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.3em;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .main-btn:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        /* Editor Screen */
        .editor-screen {
            display: none;
            min-height: 100vh;
            padding: 20px;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 40px;
        }

        .editor-screen.active {
            display: flex;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        #canvas {
            width: 100%;
            height: auto;
            display: block;
        }

        .controls {
            width: 100%;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.95);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .slider-container {
            margin-bottom: 20px;
        }

        .slider-label {
            display: block;
            margin-bottom: 10px;
            font-size: 1.1em;
            font-weight: 600;
            color: #333;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
        }

        /* Highlights slider */
        #colorSlider {
            background: linear-gradient(to right,
                #333 0%,         /* No highlights */
                #666 25%,        /* Subtle */
                #999 50%,        /* Medium */
                #ccc 75%,        /* Strong */
                #fff 100%        /* Very strong */
            );
        }

        .action-buttons {
            display: flex;
            gap: 10px;
        }

        .action-btn {
            flex: 1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            border: none;
            border-radius: 50px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
        }

        .action-btn.share {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .action-btn:active {
            transform: scale(0.95);
            opacity: 0.8;
        }

        /* Camera Modal */
        .camera-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .camera-modal.active {
            display: flex;
        }

        #video {
            max-width: 100%;
            max-height: 70vh;
            border-radius: 10px;
            transform: scaleX(-1);
        }

        .camera-controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        .camera-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .camera-btn:active {
            transform: scale(0.95);
        }

        .close-btn {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2em;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <!-- Home Screen -->
    <div class="home-screen" id="homeScreen">
        <img src="new_images/unibrow_title.png" alt="Unibrow Generator" class="title-image">
        <div class="button-container">
            <button class="main-btn" id="takePicBtn">Take a Pic</button>
            <button class="main-btn" id="uploadPicBtn">Upload a Pic</button>
        </div>
    </div>

    <!-- Editor Screen -->
    <div class="editor-screen" id="editorScreen">
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div class="controls">
            <div class="slider-container">
                <label class="slider-label">Unibrow Intensity</label>
                <input type="range" min="0" max="100" value="0" class="slider" id="unibrowSlider">
            </div>
            <div class="slider-container">
                <label class="slider-label">Darkness</label>
                <input type="range" min="-50" max="50" value="0" class="slider" id="darknessSlider">
            </div>
            <div class="slider-container">
                <label class="slider-label">Highlights</label>
                <input type="range" min="0" max="100" value="0" class="slider" id="colorSlider">
            </div>
            <div class="action-buttons">
                <button class="action-btn" id="newPicBtn">Upload New Pic</button>
                <button class="action-btn share" id="shareBtn">Share</button>
            </div>
        </div>
        <div class="loading" id="loadingText" style="display: none;">Detecting face...</div>
    </div>

    <!-- Camera Modal -->
    <div class="camera-modal" id="cameraModal">
        <video id="video" autoplay playsinline></video>
        <div class="camera-controls">
            <button class="camera-btn" id="captureBtn">Capture</button>
            <button class="camera-btn close-btn" id="closeCameraBtn">Close</button>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept="image/*" style="display: none;">

    <!-- Upload New Pic Modal -->
    <div class="camera-modal" id="newPicModal">
        <div style="display: flex; flex-direction: column; gap: 20px; max-width: 300px; width: 90%;">
            <button class="camera-btn" id="modalTakePicBtn">Take a Pic</button>
            <button class="camera-btn" id="modalUploadPicBtn">Upload a Pic</button>
            <button class="camera-btn close-btn" id="closeNewPicModal">Cancel</button>
        </div>
    </div>

    <script>
        // Elements
        const homeScreen = document.getElementById('homeScreen');
        const editorScreen = document.getElementById('editorScreen');
        const takePicBtn = document.getElementById('takePicBtn');
        const uploadPicBtn = document.getElementById('uploadPicBtn');
        const fileInput = document.getElementById('fileInput');
        const cameraModal = document.getElementById('cameraModal');
        const video = document.getElementById('video');
        const captureBtn = document.getElementById('captureBtn');
        const closeCameraBtn = document.getElementById('closeCameraBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const unibrowSlider = document.getElementById('unibrowSlider');
        const darknessSlider = document.getElementById('darknessSlider');
        const colorSlider = document.getElementById('colorSlider');
        const newPicBtn = document.getElementById('newPicBtn');
        const shareBtn = document.getElementById('shareBtn');
        const loadingText = document.getElementById('loadingText');
        const newPicModal = document.getElementById('newPicModal');
        const modalTakePicBtn = document.getElementById('modalTakePicBtn');
        const modalUploadPicBtn = document.getElementById('modalUploadPicBtn');
        const closeNewPicModal = document.getElementById('closeNewPicModal');

        let originalImage = null;
        let faceLandmarks = null;
        let stream = null;
        let faceMesh = null;

        // Initialize MediaPipe Face Mesh
        function initFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`;
                }
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onFaceMeshResults);
        }

        // Handle face mesh results
        function onFaceMeshResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                faceLandmarks = results.multiFaceLandmarks[0];
                loadingText.style.display = 'none';
                drawCanvas();
            } else {
                faceLandmarks = null;
                loadingText.textContent = 'No face detected. Please try another image.';
            }
        }

        // Process image for face detection
        async function detectFace(image) {
            loadingText.style.display = 'block';
            loadingText.textContent = 'Detecting face...';

            if (!faceMesh) {
                initFaceMesh();
            }

            await faceMesh.send({image: image});
        }

        // Draw canvas with unibrow
        function drawCanvas() {
            if (!originalImage) return;

            // Set canvas size to match image
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;

            // Draw original image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, 0, 0);

            // Draw unibrow if landmarks exist
            if (faceLandmarks && unibrowSlider.value > 0) {
                drawUnibrow();
            }
        }

        // Draw unibrow based on eyebrow landmarks
        function drawUnibrow() {
            const intensity = unibrowSlider.value / 100;
            if (intensity === 0) return;

            // Get all eyebrow landmark points for accurate shape
            // Left eyebrow landmarks (outer to inner): 46, 53, 52, 65, 55
            const leftBrowPoints = [46, 53, 52, 65, 55].map(idx => ({
                x: faceLandmarks[idx].x * canvas.width,
                y: faceLandmarks[idx].y * canvas.height
            }));

            // Right eyebrow landmarks (inner to outer): 285, 295, 282, 283, 276
            const rightBrowPoints = [285, 295, 282, 283, 276].map(idx => ({
                x: faceLandmarks[idx].x * canvas.width,
                y: faceLandmarks[idx].y * canvas.height
            }));

            // Combine into one continuous path (left to right)
            const allBrowPoints = [...leftBrowPoints, ...rightBrowPoints];

            // Add bridge points to connect the eyebrows smoothly
            const bridge = faceLandmarks[168]; // Nose bridge
            const bridgePoint = {
                x: bridge.x * canvas.width,
                y: bridge.y * canvas.height - 5
            };

            // Insert bridge point between the two eyebrows
            const fullUnibrowPath = [
                ...leftBrowPoints,
                bridgePoint,
                ...rightBrowPoints
            ];

            ctx.save();
            ctx.globalAlpha = 0.9;

            // Enable anti-aliasing for smoother hair
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Sample eyebrow color from the original image
            function sampleEyebrowColor() {
                // Sample multiple points from both eyebrows
                const samplePoints = [
                    faceLandmarks[46], faceLandmarks[53], faceLandmarks[55], // Left eyebrow
                    faceLandmarks[276], faceLandmarks[283], faceLandmarks[285] // Right eyebrow
                ];

                let totalR = 0, totalG = 0, totalB = 0;
                let samples = 0;

                samplePoints.forEach(point => {
                    const x = Math.floor(point.x * canvas.width);
                    const y = Math.floor(point.y * canvas.height);

                    // Sample a small area around each point
                    for (let dx = -2; dx <= 2; dx++) {
                        for (let dy = -2; dy <= 2; dy++) {
                            const px = x + dx;
                            const py = y + dy;
                            if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                                const pixel = ctx.getImageData(px, py, 1, 1).data;
                                totalR += pixel[0];
                                totalG += pixel[1];
                                totalB += pixel[2];
                                samples++;
                            }
                        }
                    }
                });

                // Average color
                let avgR = Math.floor(totalR / samples);
                let avgG = Math.floor(totalG / samples);
                let avgB = Math.floor(totalB / samples);

                // Apply darkness adjustment (-50 to +50)
                const darknessValue = parseInt(darknessSlider.value);
                avgR = Math.max(0, Math.min(255, avgR - darknessValue));
                avgG = Math.max(0, Math.min(255, avgG - darknessValue));
                avgB = Math.max(0, Math.min(255, avgB - darknessValue));

                // Apply highlights (0-100)
                const highlightValue = parseInt(colorSlider.value) / 100;

                // Create color variations with highlights
                // Base color stays the same, but we add lighter variations for highlights
                const colors = [
                    `rgba(${avgR}, ${avgG}, ${avgB}, 0.9)`,
                    `rgba(${Math.max(0, avgR - 15)}, ${Math.max(0, avgG - 15)}, ${Math.max(0, avgB - 15)}, 0.9)`,
                    `rgba(${Math.max(0, avgR - 30)}, ${Math.max(0, avgG - 30)}, ${Math.max(0, avgB - 30)}, 0.95)`,
                    `rgba(${Math.min(255, avgR + 10)}, ${Math.min(255, avgG + 10)}, ${Math.min(255, avgB + 10)}, 0.85)`
                ];

                // Add highlighted strands (lighter versions)
                if (highlightValue > 0) {
                    const highlightBoost = highlightValue * 80; // 0 to 80 RGB boost
                    colors.push(
                        `rgba(${Math.min(255, avgR + highlightBoost)}, ${Math.min(255, avgG + highlightBoost)}, ${Math.min(255, avgB + highlightBoost)}, 0.85)`,
                        `rgba(${Math.min(255, avgR + highlightBoost * 0.7)}, ${Math.min(255, avgG + highlightBoost * 0.7)}, ${Math.min(255, avgB + highlightBoost * 0.7)}, 0.8)`,
                        `rgba(${Math.min(255, avgR + highlightBoost * 1.2)}, ${Math.min(255, avgG + highlightBoost * 1.2)}, ${Math.min(255, avgB + highlightBoost * 1.2)}, 0.75)`
                    );
                }

                return colors;
            }

            const eyebrowColors = sampleEyebrowColor();

            // Function to interpolate along the eyebrow curve
            function getPointOnCurve(t) {
                // t is 0 to 1 along the entire curve
                const totalSegments = fullUnibrowPath.length - 1;
                const segment = Math.min(Math.floor(t * totalSegments), totalSegments - 1);
                const localT = (t * totalSegments) - segment;

                const p1 = fullUnibrowPath[segment];
                const p2 = fullUnibrowPath[segment + 1];

                return {
                    x: p1.x + (p2.x - p1.x) * localT,
                    y: p1.y + (p2.y - p1.y) * localT
                };
            }

            // Function to get the angle/direction at a point on the curve
            function getAngleAtPoint(t) {
                const totalSegments = fullUnibrowPath.length - 1;
                const segment = Math.min(Math.floor(t * totalSegments), totalSegments - 1);

                const p1 = fullUnibrowPath[segment];
                const p2 = fullUnibrowPath[segment + 1];

                // Tangent angle of the curve at this point
                const tangentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

                // Perpendicular to the curve (upward/outward from eyebrow)
                return tangentAngle - Math.PI / 2;
            }

            // Draw base hair layer following the exact eyebrow shape - MUCH BUSHIER!
            const numStrokes = Math.floor(400 + intensity * 3000);

            for (let i = 0; i < numStrokes; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                // Much wider spread for bushiness and thickness
                const spreadRadius = 40 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const randomDist = Math.random() * spreadRadius;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                // Hair grows perpendicular to eyebrow curve with more variation
                const angleVariation = (Math.random() - 0.5) * 0.8;
                const hairAngle = baseAngle + angleVariation;

                // Longer, wilder hair
                const hairLength = (15 + Math.random() * 35) * (0.6 + intensity * 1.4);
                const thickness = 1.2 + Math.random() * 2.5;

                // Use sampled eyebrow colors with varied opacity for depth
                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.7 + Math.random() * 0.3;
                ctx.strokeStyle = baseColor.replace(/[\d\.]+\)$/g, opacity + ')');
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw curved hair with more wildness and gradient effect
                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;
                const controlX = startX + Math.cos(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 5;
                const controlY = startY + Math.sin(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 5;

                // Create gradient for tapered hair effect
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.3) + ')'));
                ctx.strokeStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                ctx.stroke();
            }

            // Add MORE density layers for extreme bushiness
            const densityStrokes = Math.floor(300 + intensity * 1600);
            for (let i = 0; i < densityStrokes; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                const spreadRadius = 38 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const randomDist = Math.random() * spreadRadius;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                const angleVariation = (Math.random() - 0.5) * 0.7;
                const hairAngle = baseAngle + angleVariation;

                const hairLength = (18 + Math.random() * 40) * (0.7 + intensity * 1.2);
                const thickness = 1.5 + Math.random() * 2.8;

                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.65 + Math.random() * 0.25;

                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;

                // Tapered gradient
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.2) + ')'));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }

            // Add EXTRA thick and wild foreground hairs
            const thickHairs = Math.floor(160 + intensity * 800);
            for (let i = 0; i < thickHairs; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                const spreadRadius = 45 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const randomDist = Math.random() * spreadRadius;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                const angleVariation = (Math.random() - 0.5) * 0.9;
                const hairAngle = baseAngle + angleVariation;

                const hairLength = (22 + Math.random() * 45) * (0.8 + intensity * 1.1);
                const thickness = 2.2 + Math.random() * 3.5;

                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.8 + Math.random() * 0.2;

                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;
                const controlX = startX + Math.cos(hairAngle) * hairLength * 0.6 + (Math.random() - 0.5) * 6;
                const controlY = startY + Math.sin(hairAngle) * hairLength * 0.6 + (Math.random() - 0.5) * 6;

                // Tapered thick hair
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(0.7, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.7) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.1) + ')'));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                ctx.stroke();
            }

            // Add super wild stray hairs for maximum bushiness
            const strayHairs = Math.floor(100 + intensity * 600);
            for (let i = 0; i < strayHairs; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                const spreadRadius = 50 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const randomDist = Math.random() * spreadRadius;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                // More extreme angle variation for wild strays
                const angleVariation = (Math.random() - 0.5) * 1.2;
                const hairAngle = baseAngle + angleVariation;

                const hairLength = (18 + Math.random() * 35) * (0.9 + intensity * 0.8);
                const thickness = 1.3 + Math.random() * 2.2;

                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.6 + Math.random() * 0.3;

                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;
                const controlX = startX + Math.cos(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 8;
                const controlY = startY + Math.sin(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 8;

                // Very subtle tapered stray hair
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor);
                gradient.addColorStop(0.8, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.5) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, '0)'));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Take picture button
        takePicBtn.addEventListener('click', async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                cameraModal.classList.add('active');
            } catch (error) {
                alert('Camera access denied or unavailable.');
            }
        });

        // Capture button
        captureBtn.addEventListener('click', () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Flip back to un-mirror
            tempCtx.translate(tempCanvas.width, 0);
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(video, 0, 0);

            originalImage = new Image();
            originalImage.onload = () => {
                homeScreen.classList.add('hidden');
                editorScreen.classList.add('active');
                detectFace(originalImage);
                closeCamera();
            };
            originalImage.src = tempCanvas.toDataURL('image/jpeg', 0.95);
        });

        // Close camera
        closeCameraBtn.addEventListener('click', closeCamera);

        function closeCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            cameraModal.classList.remove('active');
        }

        // Upload picture button
        uploadPicBtn.addEventListener('click', () => {
            fileInput.click();
        });

        // File input change
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    originalImage = new Image();
                    originalImage.onload = () => {
                        homeScreen.classList.add('hidden');
                        editorScreen.classList.add('active');
                        detectFace(originalImage);
                    };
                    originalImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Slider inputs
        unibrowSlider.addEventListener('input', () => {
            drawCanvas();
        });

        darknessSlider.addEventListener('input', () => {
            drawCanvas();
        });

        colorSlider.addEventListener('input', () => {
            drawCanvas();
        });

        // Upload New Pic button - show modal
        newPicBtn.addEventListener('click', () => {
            newPicModal.classList.add('active');
        });

        // Close new pic modal
        closeNewPicModal.addEventListener('click', () => {
            newPicModal.classList.remove('active');
        });

        // Modal Take Pic button
        modalTakePicBtn.addEventListener('click', () => {
            newPicModal.classList.remove('active');
            openCamera();
        });

        // Modal Upload Pic button
        modalUploadPicBtn.addEventListener('click', () => {
            newPicModal.classList.remove('active');
            fileInput.click();
        });

        // Share button
        shareBtn.addEventListener('click', async () => {
            try {
                canvas.toBlob(async (blob) => {
                    const file = new File([blob], 'my-unibrow.png', { type: 'image/png' });

                    if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share({
                                files: [file],
                                title: 'My Unibrow Creation',
                                text: 'Check out my unibrow!'
                            });
                        } catch (err) {
                            if (err.name !== 'AbortError') {
                                alert('Could not share.');
                            }
                        }
                    } else {
                        alert('Sharing not supported on this device.');
                    }
                }, 'image/png');
            } catch (err) {
                alert('Could not share.');
            }
        });
    </script>
</body>
</html>
