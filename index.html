<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">

    <!-- iOS Home Screen App Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Unibrow Maker">
    <link rel="apple-touch-icon" href="app-icon.png">

    <title>Unibrow Maker</title>

    <!-- Face detection library -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            background: white;
            overflow-x: hidden;
        }

        .home-screen {
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            overflow: hidden;
        }

        .logo {
            padding: 15px 20px;
            margin-bottom: 25px;
            flex-shrink: 0;
        }

        .logo img {
            width: 90px;
            height: auto;
        }

        .title-image {
            padding: 0 20px;
            max-width: 350px;
            width: 80%;
            height: auto;
            margin-bottom: 0;
            flex-shrink: 0;
        }

        .hero-container {
            width: 100vw;
            position: relative;
            left: 0;
            flex: 1;
            overflow: hidden;
            margin-bottom: 5px;
            margin-top: -30px;
        }

        .hero-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            object-position: center;
        }

        .button-container {
            display: flex;
            flex-direction: row;
            gap: 0;
            padding: 0 20px 20px 20px;
            align-items: center;
            justify-content: flex-start;
            flex-shrink: 0;
        }

        .button-container img:first-child {
            margin-right: auto;
        }

        .button-container img:last-child {
            margin-left: calc(50% - 20px);
        }

        .button-container img {
            height: 25px;
            width: auto;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .button-container img:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        /* Editor Screen */
        .editor-screen {
            display: none;
            height: 100vh;
            padding: 10px;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            overflow: hidden;
        }

        .editor-screen.active {
            display: flex;
        }

        .canvas-container {
            position: relative;
            max-width: 500px;
            max-height: 50vh;
            border-radius: 10px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
            flex-shrink: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #canvas {
            max-width: 100%;
            max-height: 50vh;
            display: block;
            height: auto;
            width: auto;
        }

        .controls {
            width: 100%;
            max-width: 500px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
        }

        .slider-container {
            margin-bottom: 12px;
        }

        .slider-label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.95em;
            font-weight: 600;
            color: #333;
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
        }

        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
        }

        /* Highlights slider */
        #colorSlider {
            background: linear-gradient(to right,
                #333 0%,         /* No highlights */
                #666 25%,        /* Subtle */
                #999 50%,        /* Medium */
                #ccc 75%,        /* Strong */
                #fff 100%        /* Very strong */
            );
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }

        .action-btn {
            flex: 1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 16px;
            border: none;
            border-radius: 50px;
            font-size: 0.95em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
        }

        .action-btn.share {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .action-btn:active {
            transform: scale(0.95);
            opacity: 0.8;
        }

        /* Camera Modal */
        .camera-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 2000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .camera-modal.active {
            display: flex;
        }

        #video {
            max-width: 100%;
            max-height: 70vh;
            border-radius: 10px;
            transform: scaleX(-1);
        }

        .camera-controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        .camera-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .camera-btn:active {
            transform: scale(0.95);
        }

        .close-btn {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1em;
            margin-top: 10px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <!-- Home Screen -->
    <div class="home-screen" id="homeScreen">
        <div class="logo">
            <img src="mfah_logo.png" alt="MFAH Logo">
        </div>
        <img src="fk_unibrow_title.svg" alt="Frida Kahlo Unibrow Generator" class="title-image">
        <div class="hero-container">
            <img src="frida-eyes.jpg" alt="Frida Kahlo Eyes">
        </div>
        <div class="button-container">
            <img src="take_pic.svg" alt="Take a Pic" id="takePicBtn">
            <img src="upload_pic.svg" alt="Upload a Pic" id="uploadPicBtn">
        </div>
    </div>

    <!-- Editor Screen -->
    <div class="editor-screen" id="editorScreen">
        <div class="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
        <div class="controls">
            <div class="slider-container">
                <label class="slider-label">Unibrow Intensity</label>
                <input type="range" min="0" max="100" value="0" class="slider" id="unibrowSlider">
            </div>
            <div class="slider-container">
                <label class="slider-label">Darkness</label>
                <input type="range" min="-50" max="50" value="0" class="slider" id="darknessSlider">
            </div>
            <div class="slider-container">
                <label class="slider-label">Highlights</label>
                <input type="range" min="0" max="100" value="0" class="slider" id="colorSlider">
            </div>
            <div class="action-buttons">
                <button class="action-btn" id="newPicBtn">Upload New Pic</button>
                <button class="action-btn share" id="shareBtn">Share</button>
            </div>
        </div>
        <div class="loading" id="loadingText" style="display: none;">Detecting face...</div>
    </div>

    <!-- Camera Modal -->
    <div class="camera-modal" id="cameraModal">
        <video id="video" autoplay playsinline></video>
        <div class="camera-controls">
            <button class="camera-btn" id="captureBtn">Capture</button>
            <button class="camera-btn close-btn" id="closeCameraBtn">Close</button>
        </div>
    </div>

    <!-- Hidden file input -->
    <input type="file" id="fileInput" accept="image/*" style="display: none;">

    <!-- Upload New Pic Modal -->
    <div class="camera-modal" id="newPicModal">
        <div style="display: flex; flex-direction: column; gap: 20px; max-width: 300px; width: 90%;">
            <button class="camera-btn" id="modalTakePicBtn">Take a Pic</button>
            <button class="camera-btn" id="modalUploadPicBtn">Upload a Pic</button>
            <button class="camera-btn close-btn" id="closeNewPicModal">Cancel</button>
        </div>
    </div>

    <script>
        // Elements
        const homeScreen = document.getElementById('homeScreen');
        const editorScreen = document.getElementById('editorScreen');
        const takePicBtn = document.getElementById('takePicBtn');
        const uploadPicBtn = document.getElementById('uploadPicBtn');
        const fileInput = document.getElementById('fileInput');
        const cameraModal = document.getElementById('cameraModal');
        const video = document.getElementById('video');
        const captureBtn = document.getElementById('captureBtn');
        const closeCameraBtn = document.getElementById('closeCameraBtn');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const unibrowSlider = document.getElementById('unibrowSlider');
        const darknessSlider = document.getElementById('darknessSlider');
        const colorSlider = document.getElementById('colorSlider');
        const newPicBtn = document.getElementById('newPicBtn');
        const shareBtn = document.getElementById('shareBtn');
        const loadingText = document.getElementById('loadingText');
        const newPicModal = document.getElementById('newPicModal');
        const modalTakePicBtn = document.getElementById('modalTakePicBtn');
        const modalUploadPicBtn = document.getElementById('modalUploadPicBtn');
        const closeNewPicModal = document.getElementById('closeNewPicModal');

        let originalImage = null;
        let faceLandmarks = null;
        let stream = null;
        let faceMesh = null;
        let stampImage = null;

        // Load stamp image
        stampImage = new Image();
        stampImage.src = 'stamp.svg';

        // Initialize MediaPipe Face Mesh
        function initFaceMesh() {
            faceMesh = new FaceMesh({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${file}`;
                }
            });

            faceMesh.setOptions({
                maxNumFaces: 1,
                refineLandmarks: true,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            faceMesh.onResults(onFaceMeshResults);
        }

        // Handle face mesh results
        function onFaceMeshResults(results) {
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                faceLandmarks = results.multiFaceLandmarks[0];
                loadingText.style.display = 'none';
                drawCanvas();
            } else {
                faceLandmarks = null;
                loadingText.textContent = 'No face detected. Please try another image.';
            }
        }

        // Resize image for faster processing
        function resizeImageForProcessing(image) {
            const maxDimension = 1280;
            let width = image.width;
            let height = image.height;

            if (width <= maxDimension && height <= maxDimension) {
                return image;
            }

            const tempCanvas = document.createElement('canvas');
            if (width > height) {
                tempCanvas.width = maxDimension;
                tempCanvas.height = (height / width) * maxDimension;
            } else {
                tempCanvas.height = maxDimension;
                tempCanvas.width = (width / height) * maxDimension;
            }

            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(image, 0, 0, tempCanvas.width, tempCanvas.height);

            const resizedImage = new Image();
            resizedImage.src = tempCanvas.toDataURL('image/jpeg', 0.9);
            return resizedImage;
        }

        // Process image for face detection
        async function detectFace(image) {
            loadingText.style.display = 'block';
            loadingText.textContent = 'Detecting face...';

            if (!faceMesh) {
                loadingText.textContent = 'Loading face detection...';
                initFaceMesh();
                // Wait a bit for initialization
                await new Promise(resolve => setTimeout(resolve, 100));
            }

            loadingText.textContent = 'Analyzing image...';
            const processImage = resizeImageForProcessing(image);

            if (processImage !== image) {
                await new Promise(resolve => {
                    processImage.onload = resolve;
                });
            }

            await faceMesh.send({image: processImage});
        }

        // Draw canvas with unibrow
        function drawCanvas() {
            if (!originalImage) return;

            // Set canvas size to match image
            canvas.width = originalImage.width;
            canvas.height = originalImage.height;

            // Draw original image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(originalImage, 0, 0);

            // Draw unibrow if landmarks exist
            if (faceLandmarks && unibrowSlider.value > 0) {
                drawUnibrow();
            }

            // Draw stamp in bottom right corner
            if (stampImage && stampImage.complete) {
                ctx.save();

                // Position stamp in bottom right corner
                const stampWidth = canvas.width * 0.2; // 20% of image width
                const stampHeight = stampWidth; // Keep it square
                const margin = canvas.width * 0.03; // 3% margin from edges
                const stampX = canvas.width - stampWidth - margin;
                const stampY = canvas.height - stampHeight - margin;

                // Move to stamp position and rotate counter-clockwise slightly
                ctx.translate(stampX + stampWidth / 2, stampY + stampHeight / 2);
                ctx.rotate(-0.15); // Rotate counter-clockwise by ~8.6 degrees
                ctx.translate(-(stampX + stampWidth / 2), -(stampY + stampHeight / 2));

                // Draw stamp
                ctx.drawImage(stampImage, stampX, stampY, stampWidth, stampHeight);

                ctx.restore();
            }
        }

        // Draw unibrow based on eyebrow landmarks
        function drawUnibrow() {
            const intensity = unibrowSlider.value / 100;
            if (intensity === 0) return;

            // Get all eyebrow landmark points for accurate shape
            // Left eyebrow landmarks (outer to inner): 46, 53, 52, 65, 55
            const leftBrowPoints = [46, 53, 52, 65, 55].map(idx => ({
                x: faceLandmarks[idx].x * canvas.width,
                y: faceLandmarks[idx].y * canvas.height
            }));

            // Right eyebrow landmarks (inner to outer): 285, 295, 282, 283, 276
            const rightBrowPoints = [285, 295, 282, 283, 276].map(idx => ({
                x: faceLandmarks[idx].x * canvas.width,
                y: faceLandmarks[idx].y * canvas.height
            }));

            // Combine into one continuous path (left to right)
            const allBrowPoints = [...leftBrowPoints, ...rightBrowPoints];

            // Add bridge points to connect the eyebrows smoothly
            const bridge = faceLandmarks[168]; // Nose bridge
            const bridgePoint = {
                x: bridge.x * canvas.width,
                y: bridge.y * canvas.height - 5
            };

            // Insert bridge point between the two eyebrows
            const fullUnibrowPath = [
                ...leftBrowPoints,
                bridgePoint,
                ...rightBrowPoints
            ];

            ctx.save();
            ctx.globalAlpha = 0.9;

            // Enable anti-aliasing for smoother hair
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            // Sample eyebrow color from the original image
            function sampleEyebrowColor() {
                // Sample multiple points from both eyebrows
                const samplePoints = [
                    faceLandmarks[46], faceLandmarks[53], faceLandmarks[55], // Left eyebrow
                    faceLandmarks[276], faceLandmarks[283], faceLandmarks[285] // Right eyebrow
                ];

                let totalR = 0, totalG = 0, totalB = 0;
                let samples = 0;

                samplePoints.forEach(point => {
                    const x = Math.floor(point.x * canvas.width);
                    const y = Math.floor(point.y * canvas.height);

                    // Sample a small area around each point
                    for (let dx = -2; dx <= 2; dx++) {
                        for (let dy = -2; dy <= 2; dy++) {
                            const px = x + dx;
                            const py = y + dy;
                            if (px >= 0 && px < canvas.width && py >= 0 && py < canvas.height) {
                                const pixel = ctx.getImageData(px, py, 1, 1).data;
                                totalR += pixel[0];
                                totalG += pixel[1];
                                totalB += pixel[2];
                                samples++;
                            }
                        }
                    }
                });

                // Average color
                let avgR = Math.floor(totalR / samples);
                let avgG = Math.floor(totalG / samples);
                let avgB = Math.floor(totalB / samples);

                // Apply darkness adjustment (-50 to +50)
                // At max darkness (+50), force eyebrows to be very dark/black
                const darknessValue = parseInt(darknessSlider.value);

                if (darknessValue > 0) {
                    // Darken mode: multiply by percentage to force toward black
                    const darknessFactor = 1 - (darknessValue / 50 * 0.9); // Up to 90% darker
                    avgR = Math.floor(avgR * darknessFactor);
                    avgG = Math.floor(avgG * darknessFactor);
                    avgB = Math.floor(avgB * darknessFactor);
                } else {
                    // Lighten mode: simple subtraction
                    avgR = Math.min(255, avgR - darknessValue);
                    avgG = Math.min(255, avgG - darknessValue);
                    avgB = Math.min(255, avgB - darknessValue);
                }

                // Apply highlights (0-100)
                const highlightValue = parseInt(colorSlider.value) / 100;

                // Create color variations with highlights
                // Base color stays the same, but we add lighter variations for highlights
                const colors = [
                    `rgba(${avgR}, ${avgG}, ${avgB}, 0.9)`,
                    `rgba(${Math.max(0, avgR - 15)}, ${Math.max(0, avgG - 15)}, ${Math.max(0, avgB - 15)}, 0.9)`,
                    `rgba(${Math.max(0, avgR - 30)}, ${Math.max(0, avgG - 30)}, ${Math.max(0, avgB - 30)}, 0.95)`,
                    `rgba(${Math.min(255, avgR + 10)}, ${Math.min(255, avgG + 10)}, ${Math.min(255, avgB + 10)}, 0.85)`
                ];

                // Add highlighted strands (lighter versions)
                if (highlightValue > 0) {
                    const highlightBoost = highlightValue * 80; // 0 to 80 RGB boost
                    colors.push(
                        `rgba(${Math.min(255, avgR + highlightBoost)}, ${Math.min(255, avgG + highlightBoost)}, ${Math.min(255, avgB + highlightBoost)}, 0.85)`,
                        `rgba(${Math.min(255, avgR + highlightBoost * 0.7)}, ${Math.min(255, avgG + highlightBoost * 0.7)}, ${Math.min(255, avgB + highlightBoost * 0.7)}, 0.8)`,
                        `rgba(${Math.min(255, avgR + highlightBoost * 1.2)}, ${Math.min(255, avgG + highlightBoost * 1.2)}, ${Math.min(255, avgB + highlightBoost * 1.2)}, 0.75)`
                    );
                }

                return colors;
            }

            const eyebrowColors = sampleEyebrowColor();

            // Function to interpolate along the eyebrow curve
            function getPointOnCurve(t) {
                // t is 0 to 1 along the entire curve
                const totalSegments = fullUnibrowPath.length - 1;
                const segment = Math.min(Math.floor(t * totalSegments), totalSegments - 1);
                const localT = (t * totalSegments) - segment;

                const p1 = fullUnibrowPath[segment];
                const p2 = fullUnibrowPath[segment + 1];

                return {
                    x: p1.x + (p2.x - p1.x) * localT,
                    y: p1.y + (p2.y - p1.y) * localT
                };
            }

            // Function to get the angle/direction at a point on the curve
            function getAngleAtPoint(t) {
                const totalSegments = fullUnibrowPath.length - 1;
                const segment = Math.min(Math.floor(t * totalSegments), totalSegments - 1);

                const p1 = fullUnibrowPath[segment];
                const p2 = fullUnibrowPath[segment + 1];

                // Tangent angle of the curve at this point
                const tangentAngle = Math.atan2(p2.y - p1.y, p2.x - p1.x);

                // Perpendicular to the curve (upward/outward from eyebrow)
                return tangentAngle - Math.PI / 2;
            }

            // Helper function for gaussian distribution (more natural clustering)
            function gaussianRandom() {
                let u = 0, v = 0;
                while(u === 0) u = Math.random();
                while(v === 0) v = Math.random();
                return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
            }

            // Add randomized noise seed for variation
            const noiseSeed = Math.random() * 1000;

            // Draw base hair layer following the exact eyebrow shape - MUCH BUSHIER!
            const numStrokes = Math.floor(400 + intensity * 3000);

            for (let i = 0; i < numStrokes; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                // Much wider spread for bushiness and thickness with gaussian distribution
                const spreadRadius = 40 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                // Mix gaussian and uniform for varied clustering
                const distMix = Math.random();
                const randomDist = distMix < 0.7
                    ? Math.abs(gaussianRandom()) * spreadRadius * 0.4
                    : Math.random() * spreadRadius * 0.6;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                // Hair grows perpendicular to eyebrow curve with more variation
                // Add smooth flowing variation with randomized patterns
                const flowVariation = Math.sin(t * Math.PI * 4 + noiseSeed + i * 0.01) * 0.3;
                const turbulence = Math.sin(t * Math.PI * 7 + noiseSeed * 2) * 0.2;
                const angleVariation = (Math.random() - 0.5) * 1.0 + flowVariation + turbulence;
                const hairAngle = baseAngle + angleVariation;

                // Longer, wilder hair
                const hairLength = (15 + Math.random() * 35) * (0.6 + intensity * 1.4);
                const thickness = 1.2 + Math.random() * 2.5;

                // Use sampled eyebrow colors with varied opacity for depth
                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.4 + Math.random() * 0.4; // Softer, more varied opacity
                ctx.strokeStyle = baseColor.replace(/[\d\.]+\)$/g, opacity + ')');
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';

                // Draw curved hair with more wildness and gradient effect
                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;
                const controlX = startX + Math.cos(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 5;
                const controlY = startY + Math.sin(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 5;

                // Create gradient for tapered, soft hair effect
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.8) + ')'));
                gradient.addColorStop(0.6, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.3) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, '0)'));
                ctx.strokeStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                ctx.stroke();
            }

            // Add MORE density layers for extreme bushiness
            const densityStrokes = Math.floor(300 + intensity * 1600);
            for (let i = 0; i < densityStrokes; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                const spreadRadius = 38 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const distMix = Math.random();
                const randomDist = distMix < 0.65
                    ? Math.abs(gaussianRandom()) * spreadRadius * 0.4
                    : Math.random() * spreadRadius * 0.55;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                const flowVariation = Math.sin(t * Math.PI * 3 + noiseSeed * 0.8 + i * 0.015) * 0.25;
                const turbulence = Math.sin(t * Math.PI * 6 + noiseSeed * 1.5) * 0.15;
                const angleVariation = (Math.random() - 0.5) * 0.9 + flowVariation + turbulence;
                const hairAngle = baseAngle + angleVariation;

                const hairLength = (18 + Math.random() * 40) * (0.7 + intensity * 1.2);
                const thickness = 1.5 + Math.random() * 2.8;

                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.4 + Math.random() * 0.3;

                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;

                // Tapered gradient with soft edges
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.7) + ')'));
                gradient.addColorStop(0.5, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.4) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, '0)'));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }

            // Add EXTRA thick and wild foreground hairs
            const thickHairs = Math.floor(160 + intensity * 800);
            for (let i = 0; i < thickHairs; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                const spreadRadius = 45 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const distMix = Math.random();
                const randomDist = distMix < 0.6
                    ? Math.abs(gaussianRandom()) * spreadRadius * 0.45
                    : Math.random() * spreadRadius * 0.65;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                const flowVariation = Math.sin(t * Math.PI * 2.5 + noiseSeed * 1.2 + i * 0.02) * 0.35;
                const turbulence = Math.sin(t * Math.PI * 5 + noiseSeed * 2.5) * 0.25;
                const angleVariation = (Math.random() - 0.5) * 1.1 + flowVariation + turbulence;
                const hairAngle = baseAngle + angleVariation;

                const hairLength = (22 + Math.random() * 45) * (0.8 + intensity * 1.1);
                const thickness = 2.2 + Math.random() * 3.5;

                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.5 + Math.random() * 0.3;

                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;
                const controlX = startX + Math.cos(hairAngle) * hairLength * 0.6 + (Math.random() - 0.5) * 6;
                const controlY = startY + Math.sin(hairAngle) * hairLength * 0.6 + (Math.random() - 0.5) * 6;

                // Tapered thick hair with very soft edges
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.8) + ')'));
                gradient.addColorStop(0.5, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.5) + ')'));
                gradient.addColorStop(0.85, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.15) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, '0)'));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                ctx.stroke();
            }

            // Add super wild stray hairs for maximum bushiness
            const strayHairs = Math.floor(100 + intensity * 600);
            for (let i = 0; i < strayHairs; i++) {
                const t = Math.random();
                const basePoint = getPointOnCurve(t);
                const baseAngle = getAngleAtPoint(t);

                const spreadRadius = 50 * intensity;
                const randomAngle = Math.random() * Math.PI * 2;
                const distMix = Math.random();
                const randomDist = distMix < 0.55
                    ? Math.abs(gaussianRandom()) * spreadRadius * 0.5
                    : Math.random() * spreadRadius * 0.7;

                const startX = basePoint.x + Math.cos(randomAngle) * randomDist;
                const startY = basePoint.y + Math.sin(randomAngle) * randomDist;

                // More extreme angle variation for wild strays with flow
                const flowVariation = Math.sin(t * Math.PI * 2 + noiseSeed * 1.8 + i * 0.025) * 0.4;
                const turbulence = Math.sin(t * Math.PI * 4.5 + noiseSeed * 3) * 0.3;
                const angleVariation = (Math.random() - 0.5) * 1.4 + flowVariation + turbulence;
                const hairAngle = baseAngle + angleVariation;

                const hairLength = (18 + Math.random() * 35) * (0.9 + intensity * 0.8);
                const thickness = 1.3 + Math.random() * 2.2;

                const colorIndex = Math.floor(Math.random() * eyebrowColors.length);
                const baseColor = eyebrowColors[colorIndex];
                const opacity = 0.3 + Math.random() * 0.3;

                const endX = startX + Math.cos(hairAngle) * hairLength;
                const endY = startY + Math.sin(hairAngle) * hairLength;
                const controlX = startX + Math.cos(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 8;
                const controlY = startY + Math.sin(hairAngle) * hairLength * 0.5 + (Math.random() - 0.5) * 8;

                // Very subtle tapered stray hair with soft wispy edges
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.7) + ')'));
                gradient.addColorStop(0.6, baseColor.replace(/[\d\.]+\)$/g, (opacity * 0.3) + ')'));
                gradient.addColorStop(1, baseColor.replace(/[\d\.]+\)$/g, '0)'));
                ctx.strokeStyle = gradient;
                ctx.lineWidth = thickness;
                ctx.lineCap = 'round';

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.quadraticCurveTo(controlX, controlY, endX, endY);
                ctx.stroke();
            }

            ctx.restore();
        }

        // Take picture button
        takePicBtn.addEventListener('click', openCamera);

        // Capture button
        captureBtn.addEventListener('click', () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Flip back to un-mirror
            tempCtx.translate(tempCanvas.width, 0);
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(video, 0, 0);

            originalImage = new Image();
            originalImage.onload = () => {
                homeScreen.classList.add('hidden');
                editorScreen.classList.add('active');
                detectFace(originalImage);
                closeCamera();
            };
            originalImage.src = tempCanvas.toDataURL('image/jpeg', 0.95);
        });

        // Close camera
        closeCameraBtn.addEventListener('click', closeCamera);

        async function openCamera() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                cameraModal.classList.add('active');
            } catch (error) {
                alert('Camera access denied or unavailable.');
            }
        }

        function closeCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            cameraModal.classList.remove('active');
        }

        // Upload picture button
        uploadPicBtn.addEventListener('click', () => {
            fileInput.click();
        });

        // File input change
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                // Show loading immediately
                homeScreen.classList.add('hidden');
                editorScreen.classList.add('active');
                loadingText.style.display = 'block';
                loadingText.textContent = 'Loading image...';

                const reader = new FileReader();
                reader.onload = (event) => {
                    originalImage = new Image();
                    originalImage.onload = () => {
                        detectFace(originalImage);
                    };
                    originalImage.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Slider inputs
        unibrowSlider.addEventListener('input', () => {
            drawCanvas();
        });

        darknessSlider.addEventListener('input', () => {
            drawCanvas();
        });

        colorSlider.addEventListener('input', () => {
            drawCanvas();
        });

        // Upload New Pic button - show modal
        newPicBtn.addEventListener('click', () => {
            newPicModal.classList.add('active');
        });

        // Close new pic modal
        closeNewPicModal.addEventListener('click', () => {
            newPicModal.classList.remove('active');
        });

        // Modal Take Pic button
        modalTakePicBtn.addEventListener('click', () => {
            newPicModal.classList.remove('active');
            openCamera();
        });

        // Modal Upload Pic button
        modalUploadPicBtn.addEventListener('click', () => {
            newPicModal.classList.remove('active');
            fileInput.click();
        });

        // Share button
        shareBtn.addEventListener('click', async () => {
            try {
                canvas.toBlob(async (blob) => {
                    const file = new File([blob], 'my-unibrow.png', { type: 'image/png' });

                    if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share({
                                files: [file],
                                title: 'My Unibrow Creation',
                                text: 'Check out my unibrow!'
                            });
                        } catch (err) {
                            if (err.name !== 'AbortError') {
                                alert('Could not share.');
                            }
                        }
                    } else {
                        alert('Sharing not supported on this device.');
                    }
                }, 'image/png');
            } catch (err) {
                alert('Could not share.');
            }
        });
    </script>
</body>
</html>
