<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0">

    <!-- iOS Home Screen App Settings -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Unibrow Maker">
    <link rel="apple-touch-icon" href="app-icon.png">

    <title>Unibrow Maker - Frida Kahlo Style</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 15px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 800px;
            width: 100%;
            margin: 10px 0;
        }

        h1 {
            text-align: center;
            color: #333;
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 20px;
            font-style: italic;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 30px 20px;
            text-align: center;
            margin-bottom: 20px;
        }

        input[type="file"] {
            display: none;
        }

        .button-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 16px 24px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s;
        }

        .btn:active {
            transform: scale(0.95);
        }

        .camera-btn {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .editor-container {
            display: none;
            margin-top: 20px;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
            max-width: 100%;
        }

        canvas {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            display: block;
            touch-action: pan-y;
            cursor: move;
        }

        .icon-container {
            position: absolute;
            bottom: 15px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 10;
        }

        .action-icon {
            cursor: pointer;
            transition: transform 0.2s, opacity 0.2s;
            filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.4));
        }

        .action-icon:active {
            transform: scale(0.9);
            opacity: 0.8;
        }

        .action-icon img {
            width: 31px;
            height: auto;
            display: block;
        }

        #newIcon img {
            width: 43px;
        }

        .controls {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .button-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .download-btn {
            background: #28a745;
            flex: 1;
        }

        .reset-btn {
            background: #dc3545;
            flex: 1;
        }

        .instructions {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.1em;
            color: white;
            text-align: center;
            z-index: 20;
            line-height: 1.8;
            cursor: pointer;
            border-radius: 10px;
        }

        .instructions.hidden {
            display: none;
        }

        @media (min-width: 768px) {
            h1 {
                font-size: 2.5em;
            }
            .button-group {
                flex-direction: row;
            }
        }

        .hidden {
            display: none;
        }

        /* Camera modal */
        .camera-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .camera-modal.active {
            display: flex;
        }

        #video {
            max-width: 100%;
            max-height: 70vh;
            border-radius: 10px;
            transform: scaleX(-1);
        }

        .camera-controls {
            margin-top: 20px;
            display: flex;
            gap: 15px;
        }

        .value-display {
            display: inline-block;
            min-width: 40px;
            text-align: right;
            color: #666;
            font-weight: normal;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Unibrow Generator</h1>
        <p class="subtitle">Channel your inner Frida Kahlo</p>

        <div class="upload-area" id="uploadArea">
            <p style="margin-bottom: 15px; color: #666;">Take a selfie or upload a photo</p>
            <div class="button-group">
                <button class="btn camera-btn" id="cameraBtn">Take Photo</button>
                <button class="btn" onclick="document.getElementById('fileInput').click()">Upload Photo</button>
            </div>
            <input type="file" id="fileInput" accept="image/*">
        </div>

        <div class="editor-container" id="editorContainer">
            <div class="canvas-wrapper">
                <canvas id="canvas"></canvas>
                <div class="instructions" id="instructions">
                    <div>
                        Drag to move.<br>
                        Pinch to resize.<br>
                        Twist to rotate.<br>
                        Tap "Done" when finished.<br>
                        <br>
                        <strong>Tap the screen to begin editing.</strong>
                    </div>
                </div>
                <div class="icon-container">
                    <div class="action-icon" id="shareIcon">
                        <img src="share.svg" alt="Share">
                    </div>
                    <div class="action-icon" id="saveIcon">
                        <img src="save.svg" alt="Save">
                    </div>
                    <div class="action-icon" id="newIcon">
                        <img src="new.svg" alt="New">
                    </div>
                </div>
            </div>

            <button class="btn camera-btn" id="editModeBtn" style="margin-top: 15px; width: 100%; display: none;">Done Editing</button>

        </div>
    </div>

    <!-- Camera Modal -->
    <div class="camera-modal" id="cameraModal">
        <video id="video" autoplay playsinline></video>
        <div class="camera-controls">
            <button class="btn" id="captureBtn">Capture</button>
            <button class="btn reset-btn" id="closeCameraBtn">Close</button>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const uploadArea = document.getElementById('uploadArea');
        const editorContainer = document.getElementById('editorContainer');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const cameraBtn = document.getElementById('cameraBtn');
        const cameraModal = document.getElementById('cameraModal');
        const video = document.getElementById('video');
        const captureBtn = document.getElementById('captureBtn');
        const closeCameraBtn = document.getElementById('closeCameraBtn');
        const saveIcon = document.getElementById('saveIcon');
        const shareIcon = document.getElementById('shareIcon');
        const newIcon = document.getElementById('newIcon');
        const instructions = document.getElementById('instructions');
        const editModeBtn = document.getElementById('editModeBtn');

        // Hidden control values (no UI sliders, just internal state)
        let verticalPositionValue = 25;
        let horizontalPositionValue = 50;
        let sizeValue = 50;
        let rotationValue = 0;
        let opacityValue = 100;

        let currentImage = null;
        let unibrowImage = null;
        let stream = null;
        let isEditMode = false;

        // Load the unibrow image
        const loadUnibrowImage = () => {
            unibrowImage = new Image();
            unibrowImage.src = 'unibrow.png'; // Must be in same folder as HTML file
            unibrowImage.onerror = () => {
                alert('Could not load unibrow.png. Make sure it is in the same folder as this HTML file.');
            };
        };

        // Load unibrow on page load
        loadUnibrowImage();

        // Start editing when instructions overlay is tapped
        instructions.addEventListener('click', () => {
            if (!isEditMode) {
                instructions.classList.add('hidden');
                isEditMode = true;
                canvas.style.cursor = 'move';
                editModeBtn.style.display = 'block';
                editModeBtn.textContent = 'Done Editing';
                editModeBtn.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
            }
        });

        // Toggle edit mode with button
        editModeBtn.addEventListener('click', () => {
            isEditMode = !isEditMode;
            if (isEditMode) {
                editModeBtn.textContent = 'Done Editing';
                editModeBtn.style.background = 'linear-gradient(135deg, #dc3545 0%, #c82333 100%)';
                canvas.style.cursor = 'move';
            } else {
                editModeBtn.textContent = 'Edit';
                editModeBtn.style.background = 'linear-gradient(135deg, #28a745 0%, #20c997 100%)';
                canvas.style.cursor = 'default';
            }
        });

        // File upload
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImage(file);
        });

        // Camera
        cameraBtn.addEventListener('click', async () => {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'user', width: { ideal: 1280 }, height: { ideal: 720 } }
                });
                video.srcObject = stream;
                cameraModal.classList.add('active');
            } catch (error) {
                alert('Camera access denied or unavailable.');
            }
        });

        captureBtn.addEventListener('click', () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // Flip back to un-mirror since video preview is mirrored
            tempCtx.translate(tempCanvas.width, 0);
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(video, 0, 0);

            tempCanvas.toBlob((blob) => {
                loadImage(blob);
                closeCamera();
            }, 'image/jpeg', 0.95);
        });

        closeCameraBtn.addEventListener('click', closeCamera);

        function closeCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
            }
            cameraModal.classList.remove('active');
        }

        // Share
        shareIcon.addEventListener('click', async () => {
            try {
                // Convert canvas to blob
                canvas.toBlob(async (blob) => {
                    const file = new File([blob], 'my-unibrow.png', { type: 'image/png' });

                    // Check if Web Share API is supported
                    if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
                        try {
                            await navigator.share({
                                files: [file],
                                title: 'My Frida Kahlo Unibrow',
                                text: 'Check out my unibrow! ðŸŽ¨'
                            });
                        } catch (err) {
                            if (err.name !== 'AbortError') {
                                console.error('Share failed:', err);
                                alert('Could not share. Try downloading instead!');
                            }
                        }
                    } else {
                        // Fallback to download if sharing not supported
                        alert('Sharing not supported on this device. Image will be downloaded instead!');
                        const link = document.createElement('a');
                        link.download = 'my-unibrow.png';
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                    }
                }, 'image/png');
            } catch (err) {
                console.error('Error creating share:', err);
                alert('Could not share. Try downloading instead!');
            }
        });

        // Save/Download
        saveIcon.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'my-unibrow.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        // Reset/New
        newIcon.addEventListener('click', () => {
            uploadArea.style.display = 'block';
            editorContainer.style.display = 'none';
            currentImage = null;
            fileInput.value = '';
        });

        function loadImage(source) {
            const img = new Image();
            img.onload = () => {
                currentImage = img;

                // Set canvas size
                const maxWidth = 800;
                let width = img.width;
                let height = img.height;

                if (width > maxWidth) {
                    height = (height * maxWidth) / width;
                    width = maxWidth;
                }

                canvas.width = width;
                canvas.height = height;

                // Show editor
                uploadArea.style.display = 'none';
                editorContainer.style.display = 'block';

                // Reset to defaults
                verticalPositionValue = 25;
                horizontalPositionValue = 50;
                sizeValue = 50;
                rotationValue = 0;
                opacityValue = 100;
                isEditMode = false;
                canvas.style.cursor = 'default';

                // Show instructions overlay and hide edit button
                if (instructions) {
                    instructions.classList.remove('hidden');
                }
                editModeBtn.style.display = 'none';

                drawUnibrow();
            };

            if (source instanceof Blob) {
                img.src = URL.createObjectURL(source);
            } else {
                img.src = URL.createObjectURL(source);
            }
        }

        function drawUnibrow() {
            if (!currentImage || !unibrowImage || !unibrowImage.complete) return;

            // Clear and redraw image
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);

            // Get values
            const yPos = (verticalPositionValue / 100) * canvas.height;
            const xPos = (horizontalPositionValue / 100) * canvas.width;
            const scale = sizeValue / 100;
            const angle = (rotationValue * Math.PI) / 180;
            const alpha = opacityValue / 100;

            // Calculate scaled dimensions
            const browWidth = unibrowImage.width * scale * (canvas.width / 800);
            const browHeight = unibrowImage.height * scale * (canvas.width / 800);

            // Save context state
            ctx.save();

            // Set opacity
            ctx.globalAlpha = alpha;

            // Move to position and rotate
            ctx.translate(xPos, yPos);
            ctx.rotate(angle);

            // Draw unibrow centered at position
            ctx.drawImage(
                unibrowImage,
                -browWidth / 2,
                -browHeight / 2,
                browWidth,
                browHeight
            );

            // Restore context state
            ctx.restore();
        }

        // Touch and drag variables
        let isDragging = false;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        let initialPinchDistance = 0;
        let initialSize = 50;
        let initialRotationAngle = 0;
        let initialRotation = 0;

        // Touch start - for dragging
        canvas.addEventListener('touchstart', (e) => {
            if (!isEditMode) return; // Only handle touches in edit mode

            if (e.touches.length === 1) {
                // Single touch - start dragging
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                // Get current unibrow position
                const currentX = (horizontalPositionValue / 100) * canvas.width;
                const currentY = (verticalPositionValue / 100) * canvas.height;

                dragOffsetX = currentX - touchX;
                dragOffsetY = currentY - touchY;
                isDragging = true;
                e.preventDefault(); // Prevent scroll when editing
            } else if (e.touches.length === 2) {
                // Two fingers - start pinching and rotating
                isDragging = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                // Store initial distance for pinch
                initialPinchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialSize = sizeValue;

                // Store initial angle for rotation
                initialRotationAngle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                ) * (180 / Math.PI);
                initialRotation = rotationValue;

                e.preventDefault(); // Prevent scroll during multi-touch
            }
        });

        // Touch move - for dragging and pinching
        canvas.addEventListener('touchmove', (e) => {
            if (!isEditMode) return; // Only handle touches in edit mode

            if (e.touches.length === 1 && isDragging) {
                // Single touch - dragging
                e.preventDefault(); // Only prevent scroll when actively dragging

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                // Calculate new position by adding the offset
                const newX = touchX + dragOffsetX;
                const newY = touchY + dragOffsetY;

                // Convert to percentage
                const newHorizontal = (newX / canvas.width) * 100;
                const newVertical = (newY / canvas.height) * 100;

                // Update position with clamping
                horizontalPositionValue = Math.max(0, Math.min(100, newHorizontal));
                verticalPositionValue = Math.max(0, Math.min(100, newVertical));

                drawUnibrow();
            } else if (e.touches.length === 2) {
                e.preventDefault(); // Prevent scroll during multi-touch
                // Two fingers - pinching and rotating
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];

                // Calculate scale change for pinch
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                const scaleChange = currentDistance / initialPinchDistance;
                let newSize = initialSize * scaleChange;

                // Clamp size between min and max
                newSize = Math.max(20, Math.min(100, newSize));
                sizeValue = newSize;

                // Calculate rotation change
                const currentAngle = Math.atan2(
                    touch2.clientY - touch1.clientY,
                    touch2.clientX - touch1.clientX
                ) * (180 / Math.PI);

                let angleDiff = currentAngle - initialRotationAngle;

                // Normalize angle difference to -180 to 180
                while (angleDiff > 180) angleDiff -= 360;
                while (angleDiff < -180) angleDiff += 360;

                let newRotation = initialRotation + angleDiff;

                // Clamp rotation between min and max
                newRotation = Math.max(-90, Math.min(90, newRotation));
                rotationValue = newRotation;

                drawUnibrow();
            }
        });

        // Touch end
        canvas.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                isDragging = false;
            }
        });

        // Mouse support for desktop
        let isMouseDown = false;
        let mouseDragOffsetX = 0;
        let mouseDragOffsetY = 0;

        canvas.addEventListener('mousedown', (e) => {
            if (!isEditMode) return; // Only handle mouse in edit mode

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

            // Store the offset from current unibrow position to mouse point
            const currentX = (horizontalPositionValue / 100) * canvas.width;
            const currentY = (verticalPositionValue / 100) * canvas.height;

            mouseDragOffsetX = currentX - mouseX;
            mouseDragOffsetY = currentY - mouseY;
            isMouseDown = true;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isEditMode) return; // Only handle mouse in edit mode

            if (isMouseDown) {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate new position by adding the offset
                const newX = mouseX + mouseDragOffsetX;
                const newY = mouseY + mouseDragOffsetY;

                const newHorizontal = (newX / canvas.width) * 100;
                const newVertical = (newY / canvas.height) * 100;

                horizontalPositionValue = Math.max(0, Math.min(100, newHorizontal));
                verticalPositionValue = Math.max(0, Math.min(100, newVertical));

                drawUnibrow();
            }
        });

        canvas.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        canvas.addEventListener('mouseleave', () => {
            isMouseDown = false;
        });

        // Drag and drop for photo upload
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.style.background = '#f0f4ff';
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.style.background = '';
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.style.background = '';
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });
    </script>
</body>
</html>
